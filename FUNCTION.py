def connection_query(df, query_s):

    from pandas import to_numeric

    # функция работает со строковыми данными
    # поэтому приведем все данные в DF в строки
    df = df.applymap(str)
    # в конце работы ф-ции вернем типы данных обратно

    # сохраним изначально заданные имена колонок
    cols_init = df.columns

    # унифицированно переименуем колонки, чтобы удобно ссылаться
    cols_unify = ['id_key', 'id_user', 'phone', 'email']
    df.set_axis(labels=cols_unify, axis=1, inplace=True)

    # в конце работы функции переименуем колонки обратно

    # приведение к алгоритмическому решению
    '''cols = df.columns.to_list()[1:]'''
    input_ = query_s

    # выделяем из запроса колонку и значение
    col = input_.split(' = ')[0]
    val = input_.split(' = ')[1]

    # создаем строку запроса
    q = f'{col} == "{val}"'

    # берем из основного DF данные по id_key, удовлетворяющие запросу q
    # прямой запрос по input (связь 1-ого уровня)
    S = []
    for i in df.query(q).id_key.tolist():
        S.append(i)

    T = []  # сюда будут складываться id_key связанных данных на всех уровнях связи
    # а из S - наоборот, будут удаляться

    # для каждого 1-ого элемента из списка S осуществляем поиск связанных данных так,
    # что в конце список S останется пустой
    # для этого создаем цикл

    while S != []:

        el_ = S[0]  # берем i-ый элемент
        T.append(el_)  # сохраняем его в итоговый список связаанных id_key

        # формируем запрос
        q = f'id_key == "{el_}"'

        # сохраняем результат сформированного запроса (РСЗ)
        r = df.query(q)

        # для k-ой колонки
        for k in r.columns.tolist()[1:]:

            # сохраняем название колонки, с которой работаем
            col_ = k

            # из результата (РСЗ) возьмем данные из k-ой искомой колонки
            # это будет единственное значение (value), т.к. id_key может быть !только уникальным
            v = r[col_].iloc[0]

            # формируем запрос на поиск связанных с k-ой колонкой данных в id_key
            q = f'{col_} == "{v}"'

            # ищем связанные с этим значением (value) данные
            # и сохраняем id_key этих связанных данных
            for j in df.query(q).id_key.tolist():
                S.append(j)

        # теперь у нас есть набор id_key в списке S
        # но этот набор с дубликатами и несортированный

        # удаляем дубликаты
        S = list(dict.fromkeys(S))

        # сортируем
        S = list(map(int, S))
        S.sort()
        S = list(map(str, S))

        # теперь список S у нас отсортирован и без дубликатов
        # S должен содержать id_key, к-рые нужно еще проверить
        # но на данном этапе S как минимум содержит текущий проверяемый элемент (el_)
        # удалим из S все уже проверенные на связь id_key, к-рые сейчас - в списке T
        S = list(map(str, (set(list(map(int, S))) - set(list(map(int, T))))))
        # теперь в списке S - только те id_key, к-рые нужно еще проверить

        # рано или поздно S == [], тогда нужно выйти из цикла
        if S == []:
            break
        else:
            pass

    # вернем изначальный тип данных для колонок: ключ, id пользователя, телефон
    df[["id_key", "id_user", "phone"]] = df[["id_key", "id_user", "phone"]].apply(to_numeric)
    # вернем первоначальные названия колонок
    df.set_axis(labels=cols_init, axis=1, inplace=True)

    T = list(map(int, T))

    # возвращаем DF с запросом в качестве output
    return df.query(f'{df.columns[0]} in {T}')